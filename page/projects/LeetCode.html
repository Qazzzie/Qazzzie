<!DOCTYPE html>
<html lang="en">
  <head class="head">    
    <!-- Metadata, favicon -->
    <title>Zach Santangelo SDE</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="../../images/favicon/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="../../images/favicon/favicon.ico" type="image/x-icon" />
    <meta name="description" content="Zach's personal portfolio website">
    <meta name="keywords" content="portfolio SE SDE software development developer engineer">
    <meta name="author" content="Zach Santangelo">
    
    <!-- css -->
    <!-- <link rel="stylesheet" href="css/bootstrap.css" >
    <link rel="stylesheet" href="css/responsive.css"> -->
    <link rel="stylesheet" href="../../css/style.css">

    <!-- <link rel="stylesheet" href="css/camera.css"> -->

    <!-- Font Awesome kit https://fontawesome.com/kits/1d1249de16/use?welcome=yes for icons+animations -->
    <script src="https://kit.fontawesome.com/1d1249de16.js" crossorigin="anonymous"></script>

    <!-- Js Scripts -->
    <script async src="../../js/loadinganimation.js"></script>
    <script defer src="../../js/index.js"></script>
    
    <!-- jquery CDN -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.js"></script>
    
    <!-- boids -->
    <script src="../../js/boids/spawnBoids.js"></script>
    <script src="../../js/boids/boids.js"></script>

    <!-- Code formatting -->
    <link rel="stylesheet" href="../../css/prism.css">
    <script src="../../js/prism.js"></script>
  </head>

  <body class="body">
    <!-- loading animation -->
    <div class="se-pre-con"></div>
    <!-- nav -->
    <nav class="navigation">
      <ul class="social-nav">
        <li>
          <a href="https://twitter.com/SantangeloZach" target="_blank"><i class="fa-brands fa-twitter fa-flip" style="--fa-animation-duration: 5s;"></i></a>
        </li>  
        <li>
          <a href="https://www.linkedin.com/in/zachariah-santangelo/" target="_blank"><i class="fa-brands fa-linkedin fa-bounce" style="--fa-animation-duration: 2.5s;"></i></a>
        </li>
        <li>
          <a href="https://github.com/Qazzzie" target="_blank"><i class="fa-brands fa-github fa-spin" style="--fa-animation-duration: 4.5s;"></i></a>
        </li>
      </ul>

      <ul class="site-nav">
        <li class="site-list-item">
          <a class="sitelink" href="../../index.html" id="nav-home"><i class="fa-solid fa-house"></i></a>
        </li>
        <li class="site-list-item">
          <a class="sitelink" href="../contact.html" id="nav-contact">Contact</a>
        </li>
        <!-- <li class="site-list-item">
          <a class="sitelink" href="#navtotop" id="nav-projects">Projects</a>
        </li> -->
      </ul>
    </nav>
    
    <div id="about" class="content">
      <p1 class="header-text" style="color:#cc6d3d">LeetCode Solutions</p1>
      <p>Here you'll find my solutions to leet code problems I've worked on.</p>
    </div>

    <a class="navtotop" id="navtotop" href="#top">Top â–¶</a>


    <div class="content">
      <p1 class="header-text" style="color:#cc6d3d">Solutions</p1>
      
      <p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" class="textlink">Max Path Sum of Binary Tree (Hard)</a></p>
      <pre class="code leethard"><code class="language-python"> 
        # Zach Santangelo
        # https://leetcode.com/problems/binary-tree-maximum-path-sum/
        # Definition for a binary tree node.
        # class TreeNode:
        #     def __init__(self, val=0, left=None, right=None):
        #         self.val = val
        #         self.left = left
        #         self.right = right
        class Solution:    
            def __init__(self):
                self.Tmax = -999999 #max path for the whole tree
                
            def maxPathSum(self, root: Optional[TreeNode]) -> int:    
                #combination of lowest common ancestor only we want to find the max val path        
                if(root==None): return root
        
                def childSum(self,root): #returns the sum of max child path plus itself            
                    if(root==None):
                        return None
                    
                    leftsum = childSum(self,root.left)
                    rightsum = childSum(self,root.right)
                    maxChildSum = -9999999#val to return after checking current path mag
                    pathsum = -999999
        
                    if(leftsum!=None and rightsum!=None):
                        pathsum = leftsum + rightsum + root.val#current node's max path
                        maxChildSum=max(leftsum,rightsum) #choose largest 
                        
                    elif(leftsum == None and rightsum != None):
                        maxChildSum = rightsum
                        pathsum = maxChildSum+root.val
                        
                    elif(leftsum != None and rightsum == None):
                        maxChildSum = leftsum
                        pathsum = maxChildSum+root.val
                        
                    else: 
                        maxChildSum = 0#dont add or subtract
                        pathsum = root.val
                    print(maxChildSum, root.val)
        
                    if(pathsum > self.Tmax):
                        self.Tmax = pathsum
                        
                    return maxChildSum + root.val #give parent max single path
                
                childSum(self,root)
                return self.Tmax
      </code></pre>


      <p><a href="https://leetcode.com/problems/group-anagrams/" class="textlink">Group Anagrams (Medium)</a></p>
      <pre class="code leetmedium"><code class="language-python"> 
        # Zach Santangelo
        # https://leetcode.com/problems/group-anagrams/
        
        class Solution(object):
            def groupAnagrams(self, strs):
                """
                :type strs: List[str]
                :rtype: List[List[str]]
                """
                #list of dictionaries of letters 
                dicts = {}
        
                for word in strs:# for each word            
                    alphaWord = ''.join(sorted(word)) #sort the word alphabetically
                    print(alphaWord)
                    if(dicts.get(alphaWord)!=None):
                        dicts[alphaWord].append(word)#append the anagram to alphaWord Key
                    else:
                        dicts.update({alphaWord:[word]})
              
                print(dicts)
                
                ret = []
                reti=0
                for key, value in dicts.items():
                    ret.append([])#add a new sublist
        
                    for word in value:#add values from key to sublist
                        ret[reti].append(word)
                    
                    reti=reti+1 #increment to next sublist
                        
                return ret
      </code></pre>
      
      <p><a href="https://leetcode.com/problems/valid-parentheses/" class="textlink">Valid Parenthesis (Easy)</a></p>
      <pre class="code leeteasy"><code class="language-python"> 
        # Zach Santangelo
        # https://leetcode.com/problems/valid-parentheses/
        class Solution(object):
            def isValid(self, s):
                """
                :type s: str
                :rtype: bool
                """
                roundbrace = 0
                curlybrace = 0
                squarebrace = 0
                for brace in s:
                    #adding if we are opening braces
                    if(brace == "("):
                        roundbrace = roundbrace + 1
                    
                    if(brace == "["):
                        squarebrace = squarebrace + 1
                    
                    if(brace == "{"):
                        curlybrace = curlybrace + 1
                    
                    #if there are other kinds of open braces yet to be closed, fails.
                    if(brace == ")"):
                        if(squarebrace!=0 and curlybrace!=0):
                            return False
                        else: roundbrace = roundbrace - 1
                     
                    if(brace == "]"):
                        if(roundbrace!=0 and curlybrace!=0):
                            return False
                        else: squarebrace = squarebrace - 1
                        
                    if(brace == "}"):
                        if(squarebrace!=0 and roundbrace!=0):
                            return False
                        else: curlybrace = curlybrace - 1
                
                #if no failures, return true
                return True
      </code></pre>


      <p><a href="https://leetcode.com/problems/flood-fill" class="textlink">Flood Fill (Easy Graph)</a></p>
      <pre class="code leeteasy"><code class="language-python"> 
        #Zach Santangelo
        #https://leetcode.com/problems/flood-fill/
        class Solution:
            def solve(self, row, col, image, visited, n, m, color, oldColor):
                
                # Base Case
                if (row < 0 or row >= n or col < 0 or col >= m or image[row][col] != oldColor or (row,col) in visited):
                    return False;
                
                image[row][col]=color
                #visited[row][col] = True;
                visited.add((row, col))
                    
                #depth first, finds explores all avs before returning to numIslands for it to check next possible set of ij routes
                    
                #Move Top
                top = self.solve(row - 1, col, image, visited, n, m, color, oldColor)
                
                #Move Right
                right = self.solve (row, col + 1, image, visited, n, m, color, oldColor)
                
                #Move Down
                down = self.solve(row + 1, col, image, visited, n, m, color, oldColor)
                
                #Move Left
                left = self.solve(row, col - 1, image, visited, n, m, color, oldColor)
                
                if(not top and not right and not down and not left):
                    return True
            
            def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
                
                n = len(image)
                m = len(image[0])
                oldColor = image[sr][sc]
                
                visited = set()
         
                if(self.solve(sr, sc, image, visited, n, m, color, oldColor)):#depth first
                    return image 
      </code></pre>

      <p><a href="https://leetcode.com/problems/ransom-note/" class="textlink">Ransom Note (Easy)</a></p>
      <pre class="code leeteasy"><code class="language-python"> 
        #Zach Santangelo
        #https://leetcode.com/problems/flood-fill/
        class Solution:
            def solve(self, row, col, image, visited, n, m, color, oldColor):
                
                # Base Case
                if (row < 0 or row >= n or col < 0 or col >= m or image[row][col] != oldColor or (row,col) in visited):
                    return False;
                
                image[row][col]=color
                #visited[row][col] = True;
                visited.add((row, col))
                    
                #depth first, finds explores all avs before returning to numIslands for it to check next possible set of ij routes
                    
                #Move Top
                top = self.solve(row - 1, col, image, visited, n, m, color, oldColor)
                
                #Move Right
                right = self.solve (row, col + 1, image, visited, n, m, color, oldColor)
                
                #Move Down
                down = self.solve(row + 1, col, image, visited, n, m, color, oldColor)
                
                #Move Left
                left = self.solve(row, col - 1, image, visited, n, m, color, oldColor)
                
                if(not top and not right and not down and not left):
                    return True
            
            def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
                
                n = len(image)
                m = len(image[0])
                oldColor = image[sr][sc]
                
                visited = set()
         
                if(self.solve(sr, sc, image, visited, n, m, color, oldColor)):#depth first
                    return image 
      </code></pre>

      <p><a href="https://leetcode.com/problems/valid-anagram/" class="textlink">Valid Anagrams (Easy)</a></p>
      <pre class="code leeteasy"><code class="language-python"> 
        #Zach Santangelo
        #https://leetcode.com/problems/flood-fill/
        class Solution:
            def solve(self, row, col, image, visited, n, m, color, oldColor):
                
                # Base Case
                if (row < 0 or row >= n or col < 0 or col >= m or image[row][col] != oldColor or (row,col) in visited):
                    return False;
                
                image[row][col]=color
                #visited[row][col] = True;
                visited.add((row, col))
                    
                #depth first, finds explores all avs before returning to numIslands for it to check next possible set of ij routes
                    
                #Move Top
                top = self.solve(row - 1, col, image, visited, n, m, color, oldColor)
                
                #Move Right
                right = self.solve (row, col + 1, image, visited, n, m, color, oldColor)
                
                #Move Down
                down = self.solve(row + 1, col, image, visited, n, m, color, oldColor)
                
                #Move Left
                left = self.solve(row, col - 1, image, visited, n, m, color, oldColor)
                
                if(not top and not right and not down and not left):
                    return True
            
            def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
                
                n = len(image)
                m = len(image[0])
                oldColor = image[sr][sc]
                
                visited = set()
         
                if(self.solve(sr, sc, image, visited, n, m, color, oldColor)):#depth first
                    return image 
      </code></pre>
    </div>

    </div>
      <!-- boids -->
      <div class="boids-canvas" id="boids" style="z-index:-1;">
        <canvas class="boids"></canvas>
      </div>
    </body>

</html>
